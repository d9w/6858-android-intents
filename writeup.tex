\documentclass[12pt,a4paper]{article} 
\usepackage{verbatim}
\usepackage{listings} 
\usepackage{hyperref} 
\usepackage{url}
\usepackage{caption}
\captionsetup{font=small,justification=centering}

\begin{comment} Write a document describing the design and implementation of
your project, and turn it in along with your project's code by the final
deadline.  \end{comment}

\begin{document} \bibliographystyle{plain}

\flushleft\textbf{Exploiting common \texttt{Intent} vulnerabilities in Android %
applications}\\ \today\\

\paragraph{Members} ~\\

Kelly Casteel, \texttt{kcasteel}\\ Owen Derby, \texttt{oderby}\\ Dennis Wilson,
\texttt{dennisw}\\

\paragraph{Problem} ~\\

The Android framework allows apps and components within apps to communicate with
one another by passing messages, called
\href{https://developer.android.com/reference/android/content/Intent.html}{Intents},
which specify both a procedure to call and the arguments to use. Applications
must declare in a static manifest file which intents each component services, as
well as both application and component level permissions. While the security
vulnerabilities in outgoing Intents has been well studied
\cite{chin_analyzing_2011} and developer tools exist to limit potentially
insecure Intents, little has been done to address malicious incoming Intents.
Exploits of this nature have been discovered in firmware of various Android
phones \cite{grace_systematic_2012}, but exploits in third-party applications
are not well studied. Application developers must make sure their manifest file
has been properly configured to only accept desired Intents, which can limit
usability. We believe that developers will trust Intent input by default,
allowing malicious input to potentially crash or abuse the application.

\paragraph{Gathering apps for analysis} ~\\

We downloaded 382 applications as application package files (``apk'' for short)
files using Real Apk Leecher \cite{apkleecher}, a utility we found online. This
connects to Google Play to get applications, so all results were verified
applications in the Android market. Various keywords for potential interesting
attack vectors, such as 'camera,' 'contacts,' 'sms,' and more were used to
search for applications. The free applications from the top 60 search results,
sorted by application popularity, for each keyword were downloaded for analysis.
This ensured that the applications were popular and currently used applications;
the attacker could be fairly certain that some were already downloaded by a
potential victim.

\paragraph{Static analysis} ~\\

To start, we implemented a basic static analysis tool to aid us in identifying
potential vulnerabilities in Android applications. The tool, which is similar to
the one built by Grace, et al. \cite{grace_systematic_2012} traces through the
control flow graph of the apps to see if there are paths between publicly
accessible methods and permission uses. We built our tool using
Androguard \cite{androguard}, a python FOS library written ``to play with''
Android applications. Our tool implements the component analysis strategy from
\cite{chin_analyzing_2011} (see section 4.3) to detect public components and
then uses a control flow graph to determine which public components lead to
privileged calls, which represent potential vulnerabilities to privilege
escalation via intent spoofing attacks. Our tool operates on raw Android apks,
the compiled archives of all code required to load and run the application. We
use the apk files in order to analyze both open- and non-open-source
application.

First, we extract the manifest file from the apk and compile a list of ``open''
components: public components, protected by weak or no permissions which are
exported by the app. A component is public if the manifest specifies an intent
filter for it. However, components can override this behavior by setting the
``exported'' attribute to \texttt{false}. Next, we check for any permissions
protecting the component. Developers can also set the ``permission'' attribute
to require a certain permission to access each component, so we only reported
public, exported components which had permissions of level dangerous or normal.

After determining all open components, we need to identify all privileged calls
made by the application. We decompile the source code in the apk and search for
method calls which require the app to hold Android permissions with level
dangerous or signature. The mapping from method calls to required permissions is
derived from work in \cite{lu_chex_2012}.

Finally, we construct a control flow graph of the application and search for
paths connecting our open compnents (entry points) to our privileged method
calls (exit points), and report all paths we find as potential
vulnerabilities. These paths represent possible vulnerabilities because they
allow an unprivileged application to cause execution of privileged methods via
an intent.

\paragraph{Findings of analysis} ~\\

The permissions most commonly leaked were mostly the permissions most commonly
declared in manifest files. Either INTERNET, READ\_PHONE\_STATE, or
ACCESS\_FINE\_LOCATION were leaked in 113 of 383 applications. While exploits
are possible based on these permissions, the more active permissions, such as
CAMERA or SEND\_SMS, were much less frequently exposed. The correlation between
exposed permissions and common ones, seen below as the percent of vulnerable
permissions to declared ones, suggests that developers don't consider the
security risks of the common permissions. Users are also probably more willing
to simply allow an app to have these permissions.
\begin{table}
\caption{Permission use and leakage}
\input{stats}
\caption*{Android permissions leaked in the analyzed applicatons. Use indicates
	the number of applications that declared the permission in their
	manifest, and Vulnerabilites indicates the number of applications that
	exposed the permission.  Permissions that were declared but not exposed
	are not shown. Signature or system permissions are in bold, all others
are danerous.}
\end{table}
None of the apps leaked sensitive information (couldn't retrieve any data with
intents)...

We looked at apps which called \texttt{get.*Extra}, being any of the Android
intent data extraction calls like getBundleExtra, getCharArrayExtra,
getIntExtra, etc, and found that many were properly sanitizing the input, but
some were not. An example is Vault Hide SMS, Pics \& Videos, an app that allows
users to store SMS messages, contacts, call logs, photos, and videos in a
password-protected and encrypted space. This app leaks the permissions
GET\_TASKS, INTERNET, READ\_PHONE\_STATE, CHANGE\_COMPONENT\_ENABLED\_STATE, and
SEND\_SMS. The message sender gets number information from the user and message
data from an intent, allowing an attacker to send arbitrary text in place of the
user's original message. While the user still enters the number and knows that
the text message is being sent, this could be an effective SMS spamming
mechanism.

Found apps using common web framework which loaded arbitrary urls (without
safety checking it) from intent data.  y

\paragraph{Internet Based Exploits} ~\\ The most common vulnerability found was
apps that would load an arbitrary URL on receiving an intent. Although the
malicious app does not receive the response from their request, they can submit
forms containing any data that the app had access to, or visit malicious
websites. This has several security related implications. First, the ability to
force the user to visit an attacker controlled URL means that attackers can
learn the IP address of any user, which is one of the factors used to determine
the coarse location, which is supposed to be protected.  \\ Interestingly, the
stock Android browser will also load any URL that it receives in an Intent. This
means that any app can force the browser to visit any link using the user's
cookies. This means that phishing attacks can be embedded in apps that were not
supposed to have access to the internet in the first place.

\paragraph{Example Exploit} ~\\
We built an exploit to demonstrate the vulnerability we found in the Android browser. We developed an app that appears to the users to be a private diary. It does not request any permissions. However, when the user tries to save the diary entry, the app URL encodes the entry and uses the browser to submit it to a website we control. If the user has a login cookie saved for the zoobar website, our website changes the user's zoobar profile to the diary entry along with a timestamp and the user's IP address.

\paragraph{Conclusion} ~\\

\bibliography{writeup} \end{document}
