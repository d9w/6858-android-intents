\documentclass[12pt,a4paper]{article}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{url}

\begin{comment}
Write a document describing the design and implementation of your
project, and turn it in along with your project's code by the final
deadline.
\end{comment}

\begin{document}
\bibliographystyle{plain}

\flushleft\textbf{Exploiting common \texttt{Intent} vulnerabilities in Android %
applications}\\
\today\\

\paragraph{Members} ~\\

Kelly Casteel, \texttt{kcasteel}\\
Owen Derby, \texttt{oderby}\\
Dennis Wilson, \texttt{dennisw}\\

\paragraph{Problem} ~\\

The Android framework allows apps and components within
apps to communicate with one another by passing messages, called
\href{https://developer.android.com/reference/android/content/Intent.html}{Intents},
which specify both a procedure to call and the arguments to use. Applications
must declare in a static manifest file which intents each component services, as
well as both application and component level permissions. While the security
vulnerabilities in outgoing Intents has been well studied
\cite{chin_analyzing_2011} and developer tools exist to limit potentially
insecure Intents, little has been done to address malicious incoming Intents.
Exploits of this nature have been discovered in firmware of various Android
phones \cite{grace_systematic_2012}, but exploits in third-party applications
are not well studied. Application developers must make sure their manifest file
has been properly configured to only accept desired Intents, which can limit
usability. We believe that developers will trust Intent input by default,
allowing malicious input to potentially crash or abuse the application.

\paragraph{Gathering apps for analysis} ~\\

Talk about how Dennis found and downloaded the apps we looked at.

We downloaded 382 apps...

\paragraph{Static analysis} ~\\

To start, we implemented a basic static analysis tool to aid us in identifying
potential vulnerabilities in Android applications. Our tool operates on raw Android
application package files. First, we extract the manifest file and compile a
list of public components. Define public components. Then we decompile the
Dalvik bytecodes of the application and search for method calls which require
the app to hold Android permissions. Finally, we construct a control flow graph
of the application and search for paths connecting our open compnents (entry
points) to our privileged method calls (exit points), and report all paths we
find as potential vulnerabilities. These paths represent possible
vulnerabilities because they allow an unprivileged application to cause
execution of privileged methods via an intent.

\paragraph{Findings of analysis} ~\\

Not very many interesting permissions leaked.

None of the apps leaked sensitive information (couldn't retrieve any data with
intents)...

We looked at apps which called \texttt{get extra}, and found that many were
properly sanitizing the intent data before using it as input, but several were
not.

Found that app XXX sends SMS messages on behalf of the user, but takes arbitrary
intents as the text of the message...

Found apps using common web framework which loaded arbitrary urls (without
safety checking it) from intent data.
x
\paragraph{Common app vulnerabilites} ~\\

\paragraph{Internet Based Exploits} ~\\
The most common vulnerability found was apps that would load an arbitrary URL on receiving an intent. Although the malicious app does not receive the response from their request, they can submit forms containing any data that the app had access to, or visit malicious websites. This has several security related implications. First, the ability to force the user to visit an attacker controlled URL means that attackers can learn the IP address of any user, which is one of the factors used to determine the coarse location, which is supposed to be protected.  \\
Interestingly, the stock Android browser will also load any URL that it receives in an Intent. This means that any app can force the browser to visit any link using the user's cookies. This means that phishing attacks can be embedded in apps that were not supposed to have access to the internet in the first place.
We built an exploit with two parts. The first part is an Android app that sends an Intent to the browser with a URL pointing to a site we control: http://purple.mit.edu... \\
We transfer control back to the app by redirecting to URLs with a scheme we defined. Our app has an IntentFilter to listen for ActionView Intents using our custom scheme. These URLs can also be used to send data from our website to our app.

\paragraph{Conclusion} ~\\

\bibliography{writeup} \end{document}
