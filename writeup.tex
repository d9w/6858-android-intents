\documentclass[12pt,a4paper]{article}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{url}
\usepackage{caption}
\usepackage{fullpage}
\captionsetup{font=small,justification=centering}

\begin{comment} Write a document describing the design and implementation of
your project, and turn it in along with your project's code by the final
deadline.  \end{comment}

\title{Exploiting common \texttt{Intent} vulnerabilities in Android %
applications}
\date{\today}
\author{Kelly Casteel, \texttt{kcasteel}\\Owen Derby, \texttt{oderby}\\Dennis
 Wilson, \texttt{dennisw}}

\begin{document} \bibliographystyle{plain}

\maketitle

\paragraph{Problem} ~\\
The Android framework allows apps and components within apps to communicate with
one another by passing messages, called
\href{https://developer.android.com/reference/android/content/Intent.html}{Intents},
which effectively specify both a procedure to call and the arguments to
use. Applications must declare in a static manifest file which Intents each
component services, as well as both application and component level
permissions. While the security vulnerabilities in outgoing Intents has been
well studied \cite{chin_analyzing_2011} and developer tools exist to limit
potentially insecure Intents \cite{lu_chex_2012}, little has been done to
address malicious incoming Intents. Exploits of this nature have been discovered
in firmware of various Android phones \cite{grace_systematic_2012}, but exploits
in third-party applications are not well studied. Application developers must
make sure their manifest file has been properly configured to only accept
desired Intents, which can limit usability. We believe that developers will
trust Intent input by default, allowing malicious input to potentially crash or
abuse the application.

Our work is twofold: we developed a static analysis tool to inspect third party
applications for malicious Intent vulnerabilities, and we built a working
exploit which takes advantage of such a vulnerability.

\paragraph{Static analysis} ~\\
To start, we implemented a basic static analysis tool to aid us in identifying
potential vulnerabilities in Android applications. We are not the first to look
at such vulnerabilities \cite{chin_analyzing_2011}, nor to build such a tool
\cite{grace_systematic_2012}. However, in the absence of any freely-available
such tools, we took it as a learning opportunity to build our own (borrowing
ideas freely from the previous literature). Here, we describe the basic design
of our tool and any interesting decisions we made, but the curious reader should
reference \cite{chin_analyzing_2011} and \cite{grace_systematic_2012} for more
details.

We built our tool using Androguard \cite{androguard}, a python FOS library
written ``to play with'' Android applications. Androguard is a library built, in
part, to support creation of static analysis tools for the Android platform - it
supports disassembly and decompilation of apks into Java-approximate source code
(it doesn't recompile, but it is very nearly complete) for human-readability, as
well as intermediate basic blocks for static analysis and control-flow graph
creation. It provides basic search functionality over the decompiled basic
blocks. Despite this long list of features, a lot of work went into
understanding how to use the library (it has minimal documentation...) and
coercing it into doing what we wanted.

The tool examines execution traces through an application, looking for places
where malicious Intents might cause the program to unintentionally perform
privileged actions. We implement the component analysis strategy from
\cite{chin_analyzing_2011} (see section 4.3) to detect public components. We
also identify privileged calls made by the application
\cite{felt_android_2011}. Then we use a control flow graph of the program to
determine which public components lead to privileged calls, which represent
potential vulnerabilities. Our tool operates on raw Android apks, the compiled
archives of all code required to load and run the application. We use the apk
files in order to analyze both open- and non-open-source application.

First, we extract the manifest file from the apk and compile a list of ``open''
components: public components, protected by weak or no permissions which are
exported by the app. A component is public if the manifest specifies an Intent
filter for it. However, components can override this behavior by setting the
``exported'' attribute to \texttt{false}. Next, we check for any permissions
protecting the component. Developers can also set the ``permission'' attribute
to require a certain permission to access each component, so we only reported
public, exported components which had permissions of level dangerous or normal.

After determining all open components, we need to identify all privileged calls
made by the application. A privileged call is a method call which the Android OS
requires the calling application to hold a permission in order to execute
the call. The mapping from method calls to required permissions is
derived from work in \cite{felt_android_2011}. Using this mapping and the
decompiled source code in the apk, we search for privileged calls with
permission levels of dangerous or signature.

Finally, we construct a control flow graph of the application and search for any
paths of execution leading from an open component to a privileged call. We
report any such path found as a potential vulnerability in the analyzed
application. These paths represent possible vulnerabilities because they allow
an unprivileged application to cause execution of privileged methods via an
Intent.

Here we quickly discuss the limitations of our tool. Because our intention was
to quickly discover many vulnerabilities in 3rd party applications, but not
exhaustively so, we did not handle discontinuities in the control flow graph
resulting from callbacks (see 2.1.1 in \cite{grace_systematic_2012}). This means
there are possibly many more vulnerabilities in the applications we examined
that what we reported. Further, because Android many non-harmful methods still
require permissions, there are a lot of ``vulnerabilities'' identified which are
not very harmful in practice. For example,
\href{https://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#getNumberFromIntent\%28android.content.Intent,\%20android.content.Context\%29}{getNumberFromIntent}
requires permission CALL\_PRIVILEGED. However, without any additional
vulnerabilities in the application, such privileged call is not very
interesting. Many of the applications flagged by our tool had this sort of
``harmless'' vulnerability.

\paragraph{Gathering apps for analysis} ~\\
We downloaded 382 applications as application package files (``apk'' for short)
files using Real Apk Leecher \cite{apkleecher}, a utility we found online. This
connects to Google Play to get applications, so all results were verified
applications in the Android market. Various keywords for potential interesting
attack vectors, such as ``camera,'' ``contacts,'' ``sms,'' and more were used to
search for applications. The free applications from the top 60 search results,
sorted by application popularity, for each keyword were downloaded for analysis.
This ensured that the applications were popular and currently used applications;
the attacker could be fairly certain that some were already downloaded by a
potential victim.

\paragraph{Findings of analysis} ~\\
The permissions most commonly leaked were mostly the permissions most commonly
declared in manifest files. Either INTERNET, READ\_PHONE\_STATE, or
ACCESS\_FINE\_LOCATION were leaked in 113 of 383 applications. While exploits
are possible based on these permissions, the more active permissions, such as
CAMERA or SEND\_SMS, were much less frequently exposed. The correlation between
exposed permissions and common ones, seen below as the percent of vulnerable
permissions to declared ones, suggests that developers don't consider the
security risks of the common permissions. Users are also probably more willing
to simply allow an app to have these permissions.
\begin{table}
\caption{Permission use and leakage}
\input{stats}
\caption*{Android permissions leaked in the analyzed applicatons. Use indicates
  the number of applications that declared the permission in their
  manifest, and vulnerabilities indicates the number of applications that
  exposed the permission.  Permissions that were declared but not exposed
  are not shown. Signature or system permissions are in bold, all others
  are dangerous.}
\end{table}

We were surprised to discover that none of the flagged vulnerabilities
represented leaks of sensitive or privileged information. We confirmed this by
checking to see if any of the apps made calls to
\href{https://developer.android.com/reference/android/app/Activity.html#setResult\%28int\%29}{setResult}. Very
few did, and most were only statically setting result codes (i.e. result codes
were not informative of whether activity request succeeded or not).

We looked at apps which called \texttt{get.*Extra}, being any of the Android
Intent data extraction calls like getBundleExtra, getCharArrayExtra,
getIntExtra, etc, and found that many were properly sanitizing the input, but
some were not. An example is Vault Hide SMS, Pics \& Videos, an app that allows
users to store SMS messages, contacts, call logs, photos, and videos in a
password-protected and encrypted space. This app leaks the permissions
GET\_TASKS, INTERNET, READ\_PHONE\_STATE, CHANGE\_COMPONENT\_ENABLED\_STATE, and
SEND\_SMS. The message sender gets number information from the user and message
data from an Intent, allowing an attacker to send arbitrary text in place of the
user's original message. While the user still enters the number and knows that
the text message is being sent, this could be an effective SMS spamming
mechanism.

Found apps using common web framework which loaded arbitrary urls (without
safety checking it) from Intent data.

\paragraph{Internet Based Exploits} ~\\

The most common vulnerability found was apps that would load an arbitrary URL on
receiving an Intent. We found two apps, Jazz Internet Radio and
Sky.FM, both of which import CatalogActivity from the Flurry library, which
will load any URL sent to it in an Intent. Although a malicious app that
exploits these apps does not receive the response from the request, the app can
submit forms containing any data that the app had access to as well as visit
malicious websites. This has several security related implications. First, it
allows the attacker to exfiltrate data from the app that the user believed would
be used only by the application. Users may be less careful about giving
sensitive data to apps that they believe do not have access to the internet.
Also, a malcious app could connect to an ad server and generate
fraudulent ad clicks, while potentially depleting the user's data plan.
Finally, the ability to force the user to visit an attacker controlled URL means
that attackers can learn the IP address of any user, which is one of the factors
used to determine the coarse location, which is supposed to be protected.

Interestingly, the stock Android browser will also load any URL that it receives
in an Intent. This means that any app can force the browser to visit any link
using the user's cookies. This means that phishing attacks can be embedded in
apps that were not supposed to have access to the internet in the first place.

\paragraph{Example Exploit} ~\\

We built an exploit to demonstrate the vulnerability we found in the Android
browser. We developed an app that appears to the users to be a private diary. It
does not request any permissions. However, when the user tries to save the diary
entry, the app URL encodes the entry and uses the browser to submit it to a
website we control. If the user has a login cookie saved for the zoobar website,
our website changes the user's zoobar profile to the diary entry along with a
timestamp and the user's IP address. Control is then returned to the application
using a link click on our website, which creates an Intent. Our application's
Intent filter catches Intents of that specific URI scheme (\texttt{malware://})
and returns control to the application.

\paragraph{Conclusion} ~\\
\bibliography{writeup} \end{document}
