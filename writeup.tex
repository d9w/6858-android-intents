\documentclass[12pt,a4paper]{article} \usepackage{verbatim}
\usepackage{listings} \usepackage{hyperref} \usepackage{url}

\begin{comment} Write a document describing the design and implementation of
your project, and turn it in along with your project's code by the final
deadline.  \end{comment}

\begin{document} \bibliographystyle{plain}

\flushleft\textbf{Exploiting common \texttt{Intent} vulnerabilities in Android %
applications}\\ \today\\

\paragraph{Members} ~\\

Kelly Casteel, \texttt{kcasteel}\\ Owen Derby, \texttt{oderby}\\ Dennis Wilson,
\texttt{dennisw}\\

\paragraph{Problem} ~\\

The Android framework allows apps and components within apps to communicate with
one another by passing messages, called
\href{https://developer.android.com/reference/android/content/Intent.html}{Intents},
which specify both a procedure to call and the arguments to use. Applications
must declare in a static manifest file which intents each component services, as
well as both application and component level permissions. While the security
vulnerabilities in outgoing Intents has been well studied
\cite{chin_analyzing_2011} and developer tools exist to limit potentially
insecure Intents, little has been done to address malicious incoming Intents.
Exploits of this nature have been discovered in firmware of various Android
phones \cite{grace_systematic_2012}, but exploits in third-party applications
are not well studied. Application developers must make sure their manifest file
has been properly configured to only accept desired Intents, which can limit
usability. We believe that developers will trust Intent input by default,
allowing malicious input to potentially crash or abuse the application.

\paragraph{Gathering apps for analysis} ~\\

We downloaded 382 applications as apk files using Real Apk Leecher
\cite{apkleecher}, a utility we found online. This connects to Google Play to
get applications, so all results were verified applications in the Android
market. Various keywords for potential interesting attack vectors, such as
'camera,' 'contacts,' 'sms,' and more were used to search for applications. The
free applications from the top 60 search results, sorted by application
popularity, for each keyword were downloaded for analysis. This ensured that the
applications were popular and currently used applications; the attacker could be
fairly certain that some were already downloaded by a potential victim.

\paragraph{Static analysis} ~\\

To start, we implemented a basic static analysis tool to aid us in identifying
potential vulnerabilities in Android applications. We built our tool using
Androguard \cite{androguard}, a python FOS library written ``to play with''
Android applications.

Our tool operates on raw Android application package files (``apk'' for short),
are compiled archives of all code required to load and run the application. We
use the apk files in order to analyze both open- and non-open-source
applications. First, we extract the manifest file from the apk and compile a
list of public components exported by the app. A component is public depending
on whether it defines an intent filter and what value it sets to the
``exported'' attribute.

Define public components. Then we decompile the
Dalvik bytecodes of the application and search for method calls which require
the app to hold Android permissions. Finally, we construct a control flow graph
of the application and search for paths connecting our open compnents (entry
points) to our privileged method calls (exit points), and report all paths we
find as potential vulnerabilities. These paths represent possible
vulnerabilities because they allow an unprivileged application to cause
execution of privileged methods via an intent.

\paragraph{Findings of analysis} ~\\

The permissions most commonly leaked were mostly the permissions most commonly
declared in manifest files. Either INTERNET, READ\_PHONE\_STATE, or
ACCESS\_FINE\_LOCATION were leaked in 113 of 383 applications. While exploits
are possible based on these permissions, the more active permissions, such as
CAMERA or SEND\_SMS, were much less frequently exposed. The correlation between
exposed permissions and common ones, seen below as the percent of vulnerable
permissions to declared ones, suggests that developers don't consider the
security risks of the common permissions. Users are also probably more willing
to simply allow an app to have these permissions.

The following 252 vulnerabilites were found by the static analysis tool.

\input{stats}

None of the apps leaked sensitive information (couldn't retrieve any data with
intents)...

We looked at apps which called \texttt{get.*Extra}, being any of the Android
intent data extraction calls like getBundleExtra, getCharArrayExtra,
getIntExtra, etc, and found that many were properly sanitizing the input, but
some were not. An example is Vault Hide SMS, Pics \& Videos, an app that allows
users to store SMS messages, contacts, call logs, photos, and videos in a
password-protected and encrypted space. This app leaks the permissions
GET\_TASKS, INTERNET, READ\_PHONE\_STATE, CHANGE\_COMPONENT\_ENABLED\_STATE, and
SEND\_SMS. The message sender gets number information from the user and message
data from an intent, allowing an attacker to send arbitrary text in place of the
user's original message. While the user still enters the number and knows that
the text message is being sent, this could be an effective SMS spamming
mechanism.

Found apps using common web framework which loaded arbitrary urls (without
safety checking it) from intent data.  y

\paragraph{Common app vulnerabilites} ~\\

%I think this is already addressed above - dennis

\paragraph{Internet Based Exploits} ~\\ The most common vulnerability found was
apps that would load an arbitrary URL on receiving an intent. Although the
malicious app does not receive the response from their request, they can submit
forms containing any data that the app had access to, or visit malicious
websites. This has several security related implications. First, the ability to
force the user to visit an attacker controlled URL means that attackers can
learn the IP address of any user, which is one of the factors used to determine
the coarse location, which is supposed to be protected.  \\ Interestingly, the
stock Android browser will also load any URL that it receives in an Intent. This
means that any app can force the browser to visit any link using the user's
cookies. This means that phishing attacks can be embedded in apps that were not
supposed to have access to the internet in the first place.  We built an exploit
with two parts. The first part is an Android app that sends an Intent to the
browser with a URL pointing to a site we control: http://purple.mit.edu... \\ We
transfer control back to the app by redirecting to URLs with a scheme we
defined. Our app has an IntentFilter to listen for ActionView Intents using our
custom scheme. These URLs can also be used to send data from our website to our
app.

\paragraph{Conclusion} ~\\

\bibliography{writeup} \end{document}
